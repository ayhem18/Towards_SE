"""
This script contains my solutions for the 2-d DP problems listed in the NeetCode Roadmap
"""
from typing import List, Dict


# noinspection PyMethodMayBeStatic
class Solution:
    def target_ways(self,
                    nums: List[int],
                    target: int,
                    sums_dict: Dict[int, int],
                    memo: Dict[tuple[int, int], int] = None) -> int:
        # sums_dict: maps each index to the sum of numbers starting from that index in the original array
        # nums is assumed to be sorted
        if memo is None:
            memo = {}

        if len(nums) == 1:
            return int(nums[0] == abs(target))

        sum_left = sums_dict[len(nums)]

        if abs(target) > sum_left or (abs(target) - sum_left) % 2 != 0:
            return 0
        if abs(target) == sum_left:
            return 2 ** len([v for v in nums if v == 0])

        key = (len(nums), target)

        if key in memo:
            return memo[key]

        memo[key] = self.target_ways(nums[1:], target - nums[0], sums_dict, memo) + \
                    self.target_ways(nums[1:], target + nums[0], sums_dict, memo)

        return memo[key]

    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        # first sort the nums
        nums = sorted(nums)
        # second, build the sums_dict
        sums_dict = {}
        count = 0
        for i in range(len(nums)):
            count += nums[len(nums) - i - 1]
            sums_dict[i + 1] = count

        return self.target_ways(nums, target, sums_dict)

    def maxProfit(self, prices: List[int], memo: dict[int, int] = None) -> int:
        memo = {} if memo is None else memo
        n = len(prices)

        if n < 2:
            return 0

        if n == 2:
            return max(0, prices[1] - prices[0])

        if n in memo:
            return memo[n]

        # at this point there are at least 3 prices
        # there are 3 cases: either the broker ignore the last price
        no_sell_last = self.maxProfit(prices[:-1], memo)
        # or the brokers sells the last price
        # and in this case iterates through the possible buying days
        best_sell_mid = 0
        for i in range(len(prices) - 2, 0, -1):
            # we take the maximum between the current best sell
            # and the profit generated by buying from the 'i'-th day
            ith_day = prices[-1] - prices[i] + self.maxProfit(prices[:i - 1], memo)
            best_sell_mid = max(best_sell_mid, ith_day)

        # don't forget about the case of buying the first day, selling the last one (it is not covered by the loop)
        sell_last_buy_first = prices[-1] - prices[0]

        memo[n] = max([no_sell_last, best_sell_mid, sell_last_buy_first])
        return memo[n]


if __name__ == '__main__':
    sol = Solution()
    prices = [1,99, 99, 99, 100]
    print(sol.maxProfit(prices))